每周工作内容

>>KW14

    >>工作内容
        阅读文献，FastICA

>>KW15

    >>工作内容
        搭建FastICA计算平台，并测试了各种组合的效果

    >>成果
        假设Sa，Sb，Sc，Sd为四个源，相对应的四个测量结果为Xa，Xb，Xc，Xd，
        将Xa，Xb，Xc，Xd组合成 Y1 = Xa 和 Y2 = Xb+Xc+Xd 再进行FastICA，
        如果S到X的混合矩阵为:
            [1,     0.1,    0.1,    0.1]
            [0.1,     1,    0.1,    0.1]
            [0.1,   0.1,      1,    0.1]
            [0.1,   0.1,    0.1,      1]
            则结果很好
        但是如果S到X的混合矩阵为:
            [1,     0.9,    0.8,    0.7]
            [0.9,     1,    0.9,    0.8]
            [0.8,   0.9,      1,    0.9]
            [0.7,   0.8,    0.9,      1]
            则结果很不理想

    >>问题
        原因?


>>KW16

    >>工作内容
        搭建了FastICA的测试平台，可以测量计算结果优劣，并测量计算时间

    >>成果
        找到了在KW15中两种结果的原因，如下
        假设Sa，Sb，Sc，Sd为四个源，相对应的四个测量结果为Xa，Xb，Xc，Xd，
        将Xa，Xb，Xc，Xd组合成 Y1 = Xa 和 Y2 = Function(Xb,Xc,Xd) 再进行FastICA，
        如果要达到最优效果，那么 Y1 中b，c，d分量的比值b:c:d必须和 Y2 中b，c，d分量的比值相同，可以证明这样的话噪声最小



        >> WU: Y1中b, c, d的分量比值? 如果 Y1 = Xa, 我的理解是b, c, d的分量为0. 或者你指的是Sb, Sc, Sd在X1中的分量?
            对，就是Sa,Sb,Sc在X1中的分量



    >>问题
        但是问题是怎样可以用最小的计算获得b，c，d的比值或者说Xb，Xc，Xd的比值?

>>KW17

    >>工作内容
        准备了解PCA，
        测试了一下通过频率来区分，发现并不能，见Main4-1.py

    >>成果-1
        思路: 横向减少进行FastICA计算的数据量

        见Main5-1.py, 还需完善

        主导思想:从横向来减少运算的点，利用小波变换或者其它转换提取特征，并再进行FastICA，得到混合矩阵后再复原原来数据

        尝试按不同的(周期L)来提取信号得到新的信号为NewSignal(L,i)，即 NewSignal(L,i)=sum( X(i*L+0), X(i*L+1), ... , X(i*L+ii), 其中ii=0,1,2,3....,L ), 并将提取的很多个L长度的信号叠加，即 NewSignal(L) = sum( NewSignal(L,0), NewSignal(L,1),....,NewSignal(L,i), 其中i=0,1,2,3....len(X)/L), 得到新的长度为L信号NewSignal(L)，（应该可以用小波变换来代替）, 再将此信号取信号中L个元素的绝对值的和得到新的值 RangeSum(L)= sum( abs( NewSignal(L) ) ), 再将各个L长度得到的RangeSum(L)合并起来的到新的数列
        RangeSums=(RangeSum(1),RangeSum(2),RangeSum(3),....,RangeSum(L_max))
        然后这个数列比之前的数列在横向短了很多，同时这个数列可以进行FastICA计算，（好像可以得到和以前一样的混合矩阵，不是很确定！！！！！！）

    >>问题-1
        还没仔细研究，具体细节也没定，我不确定这样效果是否可以，计算量不知道会是增加还是减少，但是感觉这个方向似乎是可以的，目前效果不是很好

        下一步研究小波变换，打算利用小波变换来代替，同时研究一下PCA，感觉思想也很接近，就是提取特征值，减少数据长度来减少计算量

    >>成果-2
        思路: 取若干个时间点来计算FastICA，将4000个点减少到200个点，效果很好!!!

        具体见Main5-2.py

    >> WU: 成果-1 和 成果-2 是类似的思想吗? 我目前看描述的理解是, 减少 Xi 的长度, 然后进行后续的步骤.


    >>问题-2:
        目前不是很清楚怎样取点可以将效果达到最佳，最优的取点方式应该是可以覆盖各个频率点

>>KW18

    >>工作内容:
        看了一下其他fastica的文献
        看了一下机器学习

        尝试了一下对各个X求偏导来得出X中的各个成分比例，但是完全没有效果


>>KW19

    >>工作内容:
        无

>>KW20

    >>工作内容:
        再次看了fastica的推导，对如何改进W的迭代公式还是没头绪
        
        再次研究了fft，受霍夫变换的启发，我提取了X1，X2，X3，X4的fft在各个频率点的比例，并归一化，再找出叠加最多的比例值，在特定情况（正弦波组合情况下）可以比较精确的得出各个各个S源的比例。后续可待研究。


    >>工作内容2:
        对应Main4-3.py
        还未完成！！！！！！记得补充！！！！！
        大概顺序为快速傅里叶变换，比值归一化，取中位数, 可得到大致W混合矩阵，就是精确度不高, 然后对理想频率单一信号分离很差，几乎不可用，但优点是可以确定X里面占比最大的成分，我在想是否可以结合FastICA

        原W矩阵:
            [[1.         0.73333333 0.46666667 0.2       ]
            [0.73333333 1.         0.73333333 0.46666667]
            [0.46666667 0.73333333 1.         0.73333333]
            [0.2        0.46666667 0.73333333 1.        ]]

        取平均值求得的W矩阵:
            [ 1.          0.69126994  0.33139303 -0.00899028]
            [0.77640168 1.         0.76295153 0.42024895]
            [0.44713895 0.72472889 1.         0.72312893]
            [0.09402143 0.36716852 0.66250399 1.        ]

        取中位数求得的W矩阵:
            [1.         0.74778304 0.39896657 0.01946024]
            [0.82721969 1.         0.83763978 0.50323304]
            [0.51771294 0.77821692 1.         0.80407435]
            [0.15708601 0.43641356 0.74130822 1.        ]

>>KW21

    >>改进ICA分离变量版本_1.0:
        信号能量归一化(原理不太确定，但效果提升明显) -> 快速傅里叶变换 -> 比值归一化 -> 取平均值 -> W矩阵(精确度与FastICA有一定差距)

        速度大概可以提高50%
            The value of  FastICA  is :  0.08078598976135254
            The value of  FFT-ICA-fftica  is :  0.038056373596191406

        精度fastica 1%误差 vs fft方法 5%-10%误差:
            MixMatrix:
            [1.         0.86666667 0.73333333 0.6       ]
            [0.86666667 1.         0.86666667 0.73333333]
            [0.73333333 0.86666667 1.         0.86666667]
            [0.6        0.73333333 0.86666667 1.        ]

            fast ica W:
            [ 0.72767143  0.86531168  1.          0.86409234]
            [ 0.86769209  1.          0.87681336  0.73947107]
            [ 0.5985349   0.73248222  0.86686036  1.        ]
            [-1.         -0.85804178 -0.7173342  -0.58189974]

            fft ica W:
            [1.         0.81305921 0.61965827 0.51870621]
            [0.88953573 1.         0.81571589 0.67605522]
            [0.69971597 0.84164819 1.         0.8586026 ]
            [0.51545509 0.67986509 0.81825684 1.        ]


    >>改进2.0--使用短时傅里叶变换、汉宁窗:
        多次短时傅里叶变换替代整个信号的傅里叶变换，可增加速度及精确度。
        汉宁窗的增加未见有影响。


    >>改进3.0--2次迭代，有效提高SNR,最终结果如下,速度觉得还可以通过优化提高一点，对于单个信号提取应该会更快，详细参见Main4-10.py

        The time of  Fast-ICA  is :  0.07666182518005371
        The time of  FFT-ICA  is :  0.028526782989501953
        
        MixMatrix:
            [1.         0.86666667 0.73333333 0.6       ]
            [0.86666667 1.         0.86666667 0.73333333]
            [0.73333333 0.86666667 1.         0.86666667]
            [0.6        0.73333333 0.86666667 1.        ]

        fast_ica W:
            [[1.         0.87474531 0.74216674 0.60892856]
            [0.86811197 1.         0.86230532 0.73147525]
            [0.72609899 0.8593119  1.         0.86412242]
            [0.59202555 0.72654405 0.86385888 1.        ]]    
        fft_ica W:
            [[1.         0.84572278 0.6829228  0.5519727 ]
            [0.85741324 1.         0.84225024 0.67985203]
            [0.77943577 0.88697213 1.         0.8856468 ]
            [0.60873828 0.7405939  0.86084506 1.        ]]

        fast_ica Signal SNR:
            27.40563286804226 dB
        fft_ica Signal SNR:
            18.404950213971645 dB

        fast_ica sum of Correlation:
            3.9984506261448622
        fft_ica sum of Correlation:
            3.9570573536328197

        fast_ica W PSNR:
            45.24649687112511 dB
        fft_ica W PSNR:
            31.289569950760743 dB

    >>4.0在以上基础上增加阈值过滤和，PCA，对结果进行PCA，有效提高SNR，结果如下：
        fastica 12 iteration
        The time of  Fast-ICA  is :  0.052828073501586914 s
        The time of  DFFT-ICA  is :  0.03290843963623047 s
        freq:  16000
        MixMatrix:
        [[1.         0.86666667 0.73333333 0.6       ]
        [0.86666667 1.         0.86666667 0.73333333]
        [0.73333333 0.86666667 1.         0.86666667]
        [0.6        0.73333333 0.86666667 1.        ]]
        fast_ica W:
        [[1.         0.86514653 0.73223916 0.60222277]
        [0.87109916 1.         0.86072526 0.72764455]
        [0.73068623 0.8647746  1.         0.86775034]
        [0.59697991 0.73080019 0.86513626 1.        ]]
        fft_ica W:
        [[1.         0.81892986 0.65967813 0.51795185]
        [0.8870342  1.         0.85080258 0.7013581 ]
        [0.74164459 0.86741454 1.         0.87467683]
        [0.63869679 0.76411929 0.87786279 1.        ]]
        fast_ica Corr:
        3.99873664816667
        fft_ica Corr:
        3.980542852718666
        fast_ica W PSNR:
        51.05823991473014  dB
        fft_ica W PSNR:
        29.29290842318228  dB
        fast_ica Signal SNR:
        30.003348429947163  dB
        fft_ica Signal SNR:
        21.82916191492303  dB    


KW22重要: 

    大总结:

        这周尝试了很多种方法，最终得出的最优方案是“复合ICA算法”

        复合ICA算法（详见 SigComplexedICA.py 和 Main9-1复合ICA算法.py）：

            前提设定：
                S为源信号，X为采集得到的信号，A和B矩阵满足以下
                X = A @ S
                S = B @ X
                B = A^-1

            性能：  
                1、在精度略低于原始fastica情况下，时间减少为原来的 9%-30%?
                2、在精度等同于原始fastica情况下，时间减少为原来的 11%-50%?
                3、在S数量较多时，速度提升明显，但S数量较少时提升不明显

            步骤：
                1、信号按时间间隔t1采样（相当于只采用低频信号）得到采样后信号X1
                2、对采样后信号进行信号幅度比例分析，详见SigComplexedICA.py中的
                    SARICA，得到大致的 A1 矩阵
                
                3、信号按时间间隔t2采样得到采样后的信号X2
                4、将A1矩阵处理后作为B1矩阵代入到fastica，对 采样后信号X2 进行初步
                    的fastica计算，得到B2矩阵

                5、信号按时间间隔t3采样得到采样后的信号X3
                6、将B2矩阵处理后代入fastica，对 采样后信号X3 进行进一步的fastica
                    计算得到最终的B3矩阵（在低精度模式下，此步骤可省略，时间省一半多）

            局限性：
                假设有：
                X = [x1] =  [ a11 * S1, a12 * S2, a13 * S3, a14 * S4 ]
                    [x2]    [ a21 * S1, a22 * S2, a23 * S3, a24 * S4 ]
                    [x3]    [ a31 * S1, a32 * S2, a33 * S3, a34 * S4 ]
                    [x4]    [ a41 * S1, a42 * S2, a43 * S3, a44 * S4 ]
                如果要有很好的效果，则所求的S一定要在x1，x2，x3，……其中一个中所占比例
                是最大的
            
            优点：
                1、耗时很稳定，不会像fastica这样忽长忽短
                2、耗时短，特别是信号很长的时候，可以节省很长时间，但是精度几乎不变
                3、精度相对会比原始fastica高一丢丢


KW32:

    小修补：
        加入fft选项，虽然可能会略微降低速度，但是在实际应用中应该可以一定程度上消除传播时延带来的影响。

    最终测试结果（目前只用了一组8个样本）：
        平均速度约为原来的26—27倍，信噪比提升了15dB以上。

    
    
KW33：

    继续测试各项参数，在Test文件夹里面。

    A矩阵的PSNR比较有参考价值

KW35:

    ComplexICA 第二版，采用了多级采样间隔和不同的tolerance，在达到以前信噪比的同时，速度进一步下降到原来的20%，即从0.28秒减少到0.053秒。之前的方案，当信噪比于原来fastica一致时耗时为0.08秒。参数还未优化完全，应该还有改进空间。